#!/usr/bin/env ruby
#  
#  Copyright 2009-2011 Stanislav Senotrusov <stan@senotrusov.com>
# 
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


# I encountered functions and classes once, they look strange.

 
# bundle exec rtt -e development start Rtt::TestThread --foo=bar
# Process.kill("TERM", Process.pid)


RTT_TERM_TIMEOUT = 60


# This will load bundler 
require File.expand_path('config/boot')

if File.exists?(hoptoad = 'config/initializers/hoptoad.rb') && matchdata = File.read(hoptoad).match(/api_key\s*=\s*['"](.+)['"]/)
  HOPTOAD_API_KEY = matchdata[1]
end

require 'trollop'

options = Trollop::options do
  opt :environment, "Run in environment (development/production/testing)", :type => :string

  opt :user, "Run as user", :type => :string
  opt :group, "Run as group", :type => :string

  opt :log, "Logfile name (default to class_name.underscore.parameterize)", :type => :string
  opt :log_level, "Log level (debug, info, warn, error, fatal)", :type => :string 
  opt :pid, "Pidfile name (default to class_name.underscore.parameterize)", :type => :string
  
  stop_on_unknown
end


action = case ARGV.first
  when /start/i
    ARGV.shift
    options[:environment] ||= "production"
    :start
  when /stop/i
    ARGV.shift
    options[:environment] ||= "production"
    :stop
  else
    options[:environment] ||= "development"
    :console
  end

unless class_name = ARGV.shift
  Trollop::die "need class name"
end


ENV['RAILS_ENV'] ||= options[:environment]

# This will load rails framework and define application configuration class
require File.expand_path('config/application')


pidfile = "tmp/pids/#{options[:pid] || class_name.underscore.parameterize}.pid"
logfile = "log/#{options[:log] || class_name.underscore.parameterize}.log"


if action == :stop
  begin
    pid = File.read(pidfile).to_i
    Process.kill("TERM", pid)
    
    begin
      noticed = false
      (RTT_TERM_TIMEOUT/0.05).to_i.times do |count|
        sleep 0.05
        Process.getpgid(pid)
        if !noticed && count > 5/0.05
          STDOUT.puts "KILL signal will be sent in #{RTT_TERM_TIMEOUT} seconds due the lack of response to TERM, press <Ctrl>d to force that or <Ctrl>c to cancel"
          noticed = true
        end
        begin
          STDIN.read_nonblock(16)
        rescue Errno::EAGAIN
        rescue EOFError
          break
        end
      end
      Process.kill("KILL", pid)
      STDERR.puts "Sended KILL signal as process is still running after TERM"
    rescue Errno::ESRCH
    rescue Interrupt
      Process.exit false
    end
    
    Process.exit true

  rescue Errno::ENOENT
    STDERR.puts "ERROR: Pidfile #{pidfile} does not exists"
    Process.exit false
  rescue Errno::ESRCH
    STDERR.puts "ERROR: Process with pid #{pid} does not running" 
    Process.exit false
  end
end


if File.exists?(pidfile)
  begin
    Process.getpgid(pid = File.read(pidfile).to_i)
    STDERR.puts "ERROR: Process is already running with pid #{pid}"
    Process.exit false
  rescue Errno::ENOENT
  rescue Errno::ESRCH
    STDERR.puts "WARNING: Found pidfile #{pidfile} with pid #{pid}, it may be the result of an unclean shutdown"
  end
end


Rails.configuration.autoload_paths.push "#{Rails.configuration.root}/app/threads"


if action == :console
  Rails.logger = ActiveSupport::BufferedLogger.new(STDOUT)
  Rails.logger.level = ActiveSupport::BufferedLogger.const_get(options[:log_level].upcase) if options[:log_level]
else
  Rails.configuration.paths.log logfile
  Rails.configuration.log_level = options[:log_level].downcase.to_sym if options[:log_level]
end


# This will initialize Rails application, load all the application classes 
require File.expand_path('config/environment')


ActiveSupport::BufferedLogger.class_eval do
  attr_reader :log
end

Rails.logger.auto_flushing = true
Rails.logger.flush

at_exit { Rails.logger.flush }


# Below that line prefer STDOUT.write "foo\n" instead of puts, to not mix output with logger like "foofoo\n\n"
begin
  
  class_constant = begin
     class_name.constantize
    rescue NameError => exception
      Trollop::die exception.message + ". The class you specified did not found"
    end

  thread = nil
  mutex = Mutex.new
  started = false
  must_terminate = false


  # If signal handler was called second time while the first is still running, mutex inside that handler will lead to deadlock (recursive locking, ThreadError)
  # So, there is a mutex in a separate thread and exception handling by Signal.threaded_handler 
  term_signal_handler = Signal.threaded_handler do
    mutex.synchronize do
      unless must_terminate
        must_terminate = true
        thread.stop if started
      end
    end
  end

  Signal.trap(:INT,  & term_signal_handler) # Ctrl+C
  Signal.trap(:TERM, & term_signal_handler) # kill
  
  
  Signal.threaded_trap(:USR1) do
    list = Thread.list
    Rails.logger.info "Thread list: #{list.length} threads total at #{Time.now}"
    list.each_with_index do |item, index|
      Rails.logger.info item.details(:title => "#{index + 1} of #{list.length}")
    end
  end


  mutex.synchronize do
    Process.exit if must_terminate
    thread = class_constant.new
  end


  # http://timetobleed.com/5-things-you-dont-know-about-user-ids-that-will-destroy-you/
  # http://www.ruby-forum.com/topic/110492
  if options[:user] || options[:group]
    require 'etc'

    user = options[:user] ? Etc.getpwnam(options[:user]) : Etc.getpwuid(Process.euid)
    group = options[:group] ? Etc.getgrnam(options[:group]) : Etc.getgrgid(user.gid)
    
    Rails.logger.log.chown(user.uid, group.gid) if Rails.logger.respond_to?(:log) && Rails.logger.log.respond_to?(:chown)
    
    Process.initgroups(user.name, group.gid)
    
    Process::GID.change_privilege(group.gid) 
    Process::UID.change_privilege(user.uid)
  end

  
  if action == :start
    # based on Reimer Behrends notes
    # http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/87467

    Process.exit!(true) if fork  # Parent exits, child continues.
    Process.setsid               # Become session leader.
    Process.exit!(true) if fork  # Zap session leader. See http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
    
    # Is there any point to set umask here?
    # File.umask 022             # Default permissions will be 644 for files and 755 for directories
        
    # Free file descriptors and point them somewhere sensible.
    # STDOUT/ERR should better go to a logfile
    STDIN.reopen "/dev/null"  

    unless Rails.logger.respond_to?(:log) && (stdout_to = Rails.logger.log).kind_of?(IO)
      stdout_to = logfile
    end

    STDOUT.reopen(stdout_to)  
    STDERR.reopen STDOUT                                      
  end

  File.write pidfile, Process.pid
  at_exit { File.delete pidfile }

  
  mutex.synchronize do
    Process.exit if must_terminate
    thread.start
    started = true
  end
  
  
  thread.join
  
rescue ScriptError, StandardError => exception
  begin
    exception.log!
  ensure
    Process.exit(false)
  end
end

