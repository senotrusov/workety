#!/usr/bin/env ruby
# 
#  Copyright 2009 Stanislav Senotrusov <senotrusov@gmail.com>
# 
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
# 
#      http://www.apache.org/licenses/LICENSE-2.0
# 
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


# rtt -e development start FooBar --foo="BAR"


RTT_TERM_TIMEOUT = 60


# This will load bundler 
require File.expand_path('config/boot')


#require 'ruby-threads-toolkit'

#daemon = Rtt::Daemon.new

options = Trollop::options do
  opt :environment, "Run in environment (development/production/testing)", :type => :string

  opt :user, "Run as user", :type => :string
  opt :group, "Run as group", :type => :string

  opt :log, "Logfile name (default to underscored class name)", :type => :string
  opt :log_level, "Log level (debug, info, warn, error, fatal)", :type => :string 
  opt :pid, "Pidfile name (default to underscored class name)", :type => :string
  
  stop_on_unknown
end


action = case ARGV.first
  when /start/i
    ARGV.shift
    options[:environment] ||= "production"
    :start
  when /stop/i
    ARGV.shift
    options[:environment] ||= "production"
    :stop
  else
    options[:environment] ||= "development"
    :console
  end

unless class_name = ARGV.shift
  Trollop::die "need class name"
end


ENV['RAILS_ENV'] ||= options[:environment]

# This will load rails framework and define application configuration class
require File.expand_path('config/application')

pidfile = "tmp/pids/#{options[:pid] || class_name.underscore}.pid"

if action == :stop
  if File.exists?(pidfile)
    begin
      pid = File.read(pidfile).to_i
      Process.kill("TERM", pid)

      begin
        noticed = false
        (RTT_TERM_TIMEOUT/0.05).to_i.times do |count|
          sleep 0.05
          Process.getpgid(pid)
          if !noticed && count > 5/0.05
            STDOUT.puts "KILL signal will be sent in #{RTT_TERM_TIMEOUT} seconds due the lack of response to TERM, press <Ctrl>d to force that"
            noticed = true
          end
          break if STDIN.eof?
        end
        Process.kill("KILL", pid)
        STDERR.puts "Sended KILL signal as process is still running after TERM"
      rescue Errno::ESRCH
      end

    rescue Errno::ESRCH
      STDERR.puts "ERROR: Process with pid #{pid} does not running" 
    end

    File.delete pidfile
  else
    STDERR.puts "ERROR: Pidfile #{pidfile} does not exists"
  end
  exit
end

if File.exists?(pidfile)
  begin
    Process.getpgid(pid = File.read(pidfile).to_i)
    STDERR.puts "ERROR: Process is already running with pid #{pid}"
    exit 1
  rescue Errno::ESRCH
    STDERR.puts "WARNING: Found pidfile #{pidfile} with pid #{pid}, it may be the result of an unclean shutdown"
  end
end

Rails.configuration.autoload_paths.push "#{Rails.configuration.root}/app/threads"

if action == :console
  Rails.logger = ActiveSupport::BufferedLogger.new(STDOUT)
  Rails.logger.level = ActiveSupport::BufferedLogger.const_get(options[:log_level].upcase) if options[:log_level]
else
  Rails.configuration.paths.log "log/#{options[:log] || class_name.underscore}.log"
  Rails.configuration.log_level = options[:log_level].downcase.to_sym if options[:log_level]
end


# This will initialize Rails application, load all the application classes 
require File.expand_path('config/environment')


ActiveSupport::BufferedLogger.class_eval do
  attr_reader :log
end

Rails.logger.auto_flushing = true
Rails.logger.flush

at_exit { Rails.logger.flush }


class_constant = begin
   class_name.constantize
  rescue NameError => exception
    Trollop::die exception.message + ". The class you specified did not found"
  end

thread = class_constant.new


# http://timetobleed.com/5-things-you-dont-know-about-user-ids-that-will-destroy-you/
# http://www.ruby-forum.com/topic/110492
if options[:user] || options[:group]
  require 'etc'

  user = options[:user] ? Etc.getpwnam(options[:user]) : Etc.getpwuid(Process.euid)
  group = options[:group] ? Etc.getgrnam(options[:group]) : Etc.getgrgid(user.gid)
  
  Rails.logger.log.chown(user.uid, group.gid) if Rails.logger.respond_to?(:log) && Rails.logger.log.respond_to?(:chown)
  
  Process.initgroups(user.name, group.gid)
  
  Process::GID.change_privilege(group.gid) 
  Process::UID.change_privilege(user.uid)
end


File.write pidfile, Process.pid
at_exit { File.delete pidfile }


if action == :start
  # based on Reimer Behrends notes
  # http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/87467

  Process.exit!(0) if fork  # Parent exits, child continues.
  Process.setsid            # Become session leader.
  Process.exit!(0) if fork  # Zap session leader. See http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
      
  File.umask 022            # Default permissions will be 644 for files and 755 for directories
      
  # Free file descriptors and point them somewhere sensible.
  # STDOUT/ERR should better go to a logfile
  STDIN.reopen "/dev/null"  

  unless Rails.logger.respond_to?(:log) && (stdout_to = Rails.logger.log).kind_of?(IO)
    stdout_to = "log/#{options[:log] || class_name.underscore}.log"
  end

  STDOUT.reopen(stdout_to)  
  STDERR.reopen STDOUT                                      
end


thread.start

